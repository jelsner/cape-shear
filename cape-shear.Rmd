---
title: "CAPE/SHEAR vs Cluster Characteristics"
author: "James Elsner"
output: html_document
editor_options: 
  chunk_output_type: console
---

Load packages.
```{r}
library(dplyr)
library(sf)
library(ggplot2)
library(lme4)
library(lubridate)
library(xtable)
```

Load the cluster-level tornado data.
```{r}
load("BigDays.RData")

BigDays.sfdfT <- BigDays.sfdfT %>%
  mutate(A = as.numeric(HullArea)/10^10,
         CAPE = maxCAPE/1000,
         CIN = minCIN/100,
         DLBS = maxBS_deep/10,
         SLBS = maxBS_shallow/10)
dim(BigDays.sfdfT)
```

## Model Selection

Consider only CAPE, CIN, BS (deep & shallow)
```{r}
library(MASS)

modelInitial <- glm.nb(nT ~ A + Lat + Lon + Year + CAPE + CIN + DLBS + SLBS, data = BigDays.sfdfT)
summary(modelInitial)

modelInitialPoisson <- glm(nT ~ A + Lat + Lon + CAPE + CIN + DLBS + SLBS, family = "poisson", data = BigDays.sfdfT)
summary(modelInitialPoisson)

modelFinal <- glm.nb(nT ~ A + CAPE + DLBS + SLBS, data = BigDays.sfdfT)
summary(modelFinal)

(exp(coef(modelFinal)) - 1) * 100

summary(lm(log(nT) ~ HullArea + maxCAPE + maxBS_deep + maxBS_shallow, data = BigDays.sfdfT))


hist(resid(modelFinal))
range(exp(predict(modelFinal)))
plot(log(BigDays.sfdfT$nT), predict(modelFinal))
cor(BigDays.sfdfT$nT, predict(modelFinal, type = "response"))

modelglmer.nb <- glmer.nb(nT ~ scale(HullArea) + scale(maxCAPE) + scale(maxBS_deep) + scale(maxBS_shallow) + (1|Season), data = BigDays.sfdfT)
summary(modelglmer.nb) # no convergence if interaction term is included

summary(glm.nb(nT ~ scale(HullArea) + scale(maxCAPE) + scale(avgCIN) + scale(maxBS_deep) + scale(maxBS_shallow), data = BigDays.sfdfT))

modelFinal <- glm.nb(nT ~ HullArea + maxCAPE + maxBS_deep + maxBS_shallow, data = BigDays.sfdfT[BigDays.sfdfT$Mo %in% c(10, 11),])
summary(modelFinal)

modelInitialC <- glm.nb(GroupDayCas ~ totalPOP + maxCAPE + minCIN + maxBS_deep + maxBS_shallow + Lat + Lon + Year, data = BigDays.sfdfT)
summary(modelInitialC)

modelFinalC <- glm.nb(GroupDayCas ~ totalPOP + maxCAPE + maxBS_deep + maxBS_shallow + Lat + Lon + Year, data = BigDays.sfdfT)
summary(modelFinalC)
hist(resid(modelFinalC))
range(exp(predict(modelFinalC)))
plot(log(BigDays.sfdfT$GroupDayCas), predict(modelFinalC))
cor(BigDays.sfdfT$GroupDayCas, exp(predict(modelFinalC)))
```

## Cross validation
```{r}
logCount <- numeric()
for(i in 1:nrow(BigDays.sfdfT)){
logCount[i] <- predict(glm.nb(nT ~ HullArea + maxCAPE + maxBS_deep + maxBS_shallow, data = BigDays.sfdfT[-i, ]), 
                       newdata = BigDays.sfdfT[i,])
}
cor(BigDays.sfdfT$nT, exp(logCount))
```

## Predictions 1-D
```{r}
theta <- 6.246
nTthresh <- 25
predict(modelFinal, newdata = data.frame(A = c(mean(BigDays.sfdfT$A), mean(BigDays.sfdfT$A)),
                                         CAPE = c(0, 5),
                                         DLBS = c(mean(BigDays.sfdfT$DLBS), mean(BigDays.sfdfT$DLBS)),
                                         SLBS = c(mean(BigDays.sfdfT$SLBS), mean(BigDays.sfdfT$SLBS))),
        type = "response")

1 - pnbinom(nTthresh, size = theta, mu = 18.725) # chance that the outbreak will have more than 50 tornadoes when CAPE = 0
1 - pnbinom(nTthresh, size = theta, mu = 23.55)  # chance that the outbreak will have more than 50 tornadoes when CAPE = 5000

predictions  <- predict(modelFinal, 
                        newdata = data.frame(A = rep(mean(BigDays.sfdfT$A), times = 6),
                                             CAPE = 0:5,
                                             DLBS = rep(mean(BigDays.sfdfT$DLBS), times = 6),
                                             SLBS = rep(mean(BigDays.sfdfT$SLBS), times = 6)),
                        type = "response")

predictions  <- predict(modelFinal, 
                        newdata = data.frame(A = mean(BigDays.sfdfT$A),
                                             CAPE = mean(BigDays.sfdfT$CAPE),
                                             DLBS = seq(1, 4, by = .25),
                                             SLBS = mean(BigDays.sfdfT$SLBS)),
                        type = "response",
                        se.fit = TRUE)
plot.predictions <- data.frame(probability = 1 - pnbinom(nTthresh, size = theta, mu = predictions$fit),
                               probabilityU = 1 - pnbinom(nTthresh, size = theta, mu = predictions$fit + 2 * predictions$se.fit),
                               probabilityL = 1 - pnbinom(nTthresh, size = theta, mu = predictions$fit - 2 * predictions$se.fit),
                               DLBS = seq(1, 4, by = .25) * 10)

library(ggplot2)
ggplot(plot.predictions, aes(x = DLBS, y = probability)) +
  geom_line() +
  geom_ribbon(aes(ymin = probabilityL, ymax = probabilityU),
              alpha = .7, col = NA, fill = "gray70") +
  scale_y_continuous(limits = c(0, NA)) +
  ylab("Probability of more than 25 tornadoes") +
  theme_minimal()
```

## Predictions 2-D
```{r}
library(directlabels)

pgrid <- expand.grid(CAPE = seq(1, 5, .25),
                     DLBS = seq(1, 4, .25),
                     A = mean(BigDays.sfdfT$A),
                     SLBS = mean(BigDays.sfdfT$SLBS))

predictions <- predict.glm(modelFinal, newdata = pgrid, type = "response")
pgrid$probability <-1 - pnbinom(50, size = 1, mu = predictions)

( p <- ggplot(pgrid, aes(x = CAPE * 1000, y = DLBS * 10, fill = probability)) +
          geom_raster() +
#  scale_fill_viridis_c()
          scale_fill_continuous(low = 'green', high = 'red') +
          geom_contour(aes(color = ..level.., z = probability), breaks = c(.05, .075, .1, .125, .15), color = "black") +
          theme_minimal() )
direct.label(p, list("angled.boxes"))
```

## CAPE-Shear

```{r}
df <- BigDays.sfdfT %>% 
  st_drop_geometry() %>%
  dplyr::select(Y = DLBS, X = CAPE, Z = GroupDayFat)
cor(df$Y, df$X)

theta = seq(1, 180, by = 1)
r = NULL ; pval = NULL
for (k in theta){
  C1 = cos(k * pi/180)
  C2 = sin(k * pi/180)
  CapeShear = C1 * scale(df$X) + C2 * scale(df$Y)
  ctest = cor.test(CapeShear, df$Z)
  r = c(r, as.numeric(ctest$estimate))
  pval = c(pval, as.numeric(ctest$p.value))
}
range(r)

signif = .01
plot(-10, -10, xlim=c(-.75, 1.05), ylim=c(-.75, 1.05), axes=FALSE, xlab='', ylab='', main='')

i = seq(0, 360, .5)
Outl = cbind(.75 * cos(i * pi/180), .75 *sin(i * pi/180))
Innl = cbind(.25 * cos(i * pi/180), .25 * sin(i * pi/180))

polygon(Outl[, 1], Outl[, 2], border=colors()[229], col='white', lwd=2)
polygon(Innl[, 1], Innl[, 2], border=colors()[229], col=NULL, lwd=2)

Line.xcord = c(-.75, .75, NA, 0, 0, NA, -cos(pi/4), cos(pi/4), NA, -cos(pi/4), cos(pi/4))
Line.ycord = c(0, 0, NA, -.75, .75, NA, sin(pi/4), -sin(pi/4), NA, -sin(pi/4), sin(pi/4))
lines(Line.xcord, Line.ycord, col=colors()[229], lwd=1)

text(par('usr')[2] - 0.29, 0.0, srt=0, adj = 0, labels = 'CAPE', xpd = TRUE, cex=1.3) 
text(par('usr')[2] - 0.6, 0.81, srt=0, adj = 0, labels = '', xpd = TRUE, cex=1.3)
text(par('usr')[2] - 1.52, 1.17, srt=0, adj = 0, labels = 'DLBS', xpd = TRUE, cex=1.3)
text(par('usr')[2] - 0.6, -0.81, srt=0, adj = 0, labels = '', xpd = TRUE, cex=1.3)
text(0,0.3, '0.25', cex=1.4, col=colors()[229])
text(0,0.8, '0.75', cex=1.4, col=colors()[229])

dg = theta
polygon(r * cos(dg * pi/180), r * sin(dg * pi/180), border="#ff9900", lwd=7, col=NULL)
r2 = c(r[which.max(pval):length(pval)], r[1:(which.max(pval) - 1)])
pval2 = c(pval[which.max(pval):length(pval)], pval[1:(which.max(pval) - 1)])
dg2 = c(dg[which.max(pval):length(pval)], dg[1:(which.max(pval) - 1)])
lines(r2[pval2 <= signif] * cos(dg2[pval2 <= signif] * pi/180),
      r2[pval2 <= signif] * sin(dg2[pval2 <= signif] * pi/180), col="#cc3300", lwd=7) 
```

## Trends
```{r}
BigDays.sfdfT %>%
#  filter(Mo %in% c(3, 4, 5, 6)) %>%
  group_by(Year) %>%
  summarize(Avg = mean(SLBS)) %>%
ggplot(aes(x = Year, y = Avg)) +
  geom_point() +
  geom_smooth(method = lm)
```

