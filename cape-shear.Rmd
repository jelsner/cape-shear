---
title: "CAPE/SHEAR vs Cluster Characteristics"
author: "James Elsner"
output: html_document
editor_options: 
  chunk_output_type: console
---

Load packages.
```{r}
library(dplyr)
library(sf)
library(ggplot2)
library(lme4)
library(lubridate)
```

Load the cluster-level tornado data.
```{r}
load("BigDays.RData")

BigDays.sfdfT <- BigDays.sfdfT %>%
  mutate(TorPerHour = nT/as.numeric(Duration) * 3600,
         TorPerKm = nT/as.numeric(HullArea) * 10^6)
dim(BigDays.sfdfT)
```

## Log-linear models

I think we should simplify things by using log-linear models. Cluster size, cluster area, and tornado production rate.
```{r}
summary(lm(log(nT) ~  maxCAPE * maxBS_deep + maxBS_shallow + minCIN  + maxVSTM + totalPOP, data = BigDays.sfdfT))

summary(lmer(log(nT) ~  maxCAPE * maxBS_deep + maxBS_shallow + minCIN  + maxVSTM + totalPOP + (1|Month), data = BigDays.sfdfT))
summary(glm(I(nT-10) ~  maxCAPE * maxBS_deep + maxBS_shallow + minCIN  + maxVSTM + totalPOP, family = "poisson", data = BigDays.sfdfT))


summary(lm(log(as.numeric(HullArea)) ~  maxCAPE + maxBS_shallow + minCIN + maxVSTM + maxUSTM + totalPOP, data = BigDays.sfdfT))
summary(lm(log(TorPerHour) ~  maxBS_deep + minCIN  + Lat + Lon + totalPOP, data = BigDays.sfdfT))
```

## CAPE-Shear

```{r}
df <- BigDays.sfdfT %>% 
# filter(Mo %in% c(9, 10, 11)) %>%
  st_drop_geometry() %>%
  select(Y = maxCAPE, X = maxBS_deep, Z = nT)
cor(df$Y, df$X)

theta = seq(1, 180, by = 1)
r = NULL ; pval = NULL
for (k in theta){
  C1 = cos(k * pi/180)
  C2 = sin(k * pi/180)
  CapeShear = C1 * scale(df$X) + C2 * scale(df$Y)
  ctest = cor.test(CapeShear, df$Z)
  r = c(r, as.numeric(ctest$estimate))
  pval = c(pval, as.numeric(ctest$p.value))
}
range(r)

plot.df <- data.frame(theta, C1 = cos(theta * pi/180), C2 = sin(theta * pi/180), r)
ggplot(plot.df, aes(x = C1, y = C2, color = r)) +
  geom_line() +
  coord_polar()
  

signif = .01
plot(-10, -10, xlim=c(-.75, 1.05), ylim=c(-.75, 1.05), axes=FALSE, xlab='', ylab='', main='')

i = seq(0, 360, .5)
Outl = cbind(.75 * cos(i * pi/180), .75 *sin(i * pi/180))
Innl = cbind(.25 * cos(i * pi/180), .25 * sin(i * pi/180))

polygon(Outl[, 1], Outl[, 2], border=colors()[229], col='white', lwd=2)
polygon(Innl[, 1], Innl[, 2], border=colors()[229], col=NULL, lwd=2)

Line.xcord = c(-.75, .75, NA, 0, 0, NA, -cos(pi/4), cos(pi/4), NA, -cos(pi/4), cos(pi/4))
Line.ycord = c(0, 0, NA, -.75, .75, NA, sin(pi/4), -sin(pi/4), NA, -sin(pi/4), sin(pi/4))
lines(Line.xcord, Line.ycord, col=colors()[229], lwd=1)

text(par('usr')[2] - 0.29, 0.0, srt=0, adj = 0, labels = 'Shear', xpd = TRUE, cex=1.3) 
text(par('usr')[2] - 0.6, 0.81, srt=0, adj = 0, labels = '', xpd = TRUE, cex=1.3)
text(par('usr')[2] - 1.52, 1.17, srt=0, adj = 0, labels = 'CAPE', xpd = TRUE, cex=1.3)
text(par('usr')[2] - 0.6, -0.81, srt=0, adj = 0, labels = '', xpd = TRUE, cex=1.3)
text(0,0.3, '0.25', cex=1.4, col=colors()[229])
text(0,0.8, '0.75', cex=1.4, col=colors()[229])

dg = theta
polygon(r * cos(dg * pi/180), r * sin(dg * pi/180), border="#ff9900", lwd=7, col=NULL)
r2 = c(r[which.max(pval):length(pval)], r[1:(which.max(pval) - 1)])
pval2 = c(pval[which.max(pval):length(pval)], pval[1:(which.max(pval) - 1)])
dg2 = c(dg[which.max(pval):length(pval)], dg[1:(which.max(pval) - 1)])
lines(r2[pval2 <= signif] * cos(dg2[pval2 <= signif] * pi/180),
      r2[pval2 <= signif] * sin(dg2[pval2 <= signif] * pi/180), col="#cc3300", lwd=7) 
```

