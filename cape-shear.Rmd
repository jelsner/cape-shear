---
title: "CAPE/SHEAR vs Cluster Characteristics"
author: "James Elsner"
output: html_document
editor_options: 
  chunk_output_type: console
---

Load packages.
```{r}
library(dplyr)
library(sf)
library(ggplot2)
library(lme4)
library(lubridate)
library(xtable)
```

Load the cluster-level tornado data.
```{r}
load("BigDays.RData")

BigDays.sfdfT <- BigDays.sfdfT %>%
#  filter(ID != 200305302651) %>%
  mutate(A = as.numeric(HullArea)/10^10,
         CAPE = maxCAPE/1000,
         CIN = minCIN/100,
         DLBS = maxBS_deep/10,
         SLBS = maxBS_shallow/10)
dim(BigDays.sfdfT)
```

## Model Selection

Consider only CAPE, CIN, BS (deep & shallow)
```{r}
modelInitial <- glm.nb(nT ~ A + Lat + Lon + CAPE + CIN + DLBS + SLBS, data = BigDays.sfdfT)
summary(modelInitial)

modelFinal <- glm.nb(nT ~ A + CAPE + DLBS + SLBS, data = BigDays.sfdfT)
summary(modelFinal)

(exp(coef(modelFinal)) - 1) * 100

summary(lm(log(nT) ~ HullArea + maxCAPE + maxBS_deep + maxBS_shallow, data = BigDays.sfdfT))


hist(resid(modelFinal))
range(exp(predict(modelFinal)))
plot(log(BigDays.sfdfT$nT), predict(modelFinal))
cor(BigDays.sfdfT$nT, exp(predict(modelFinal)))

modelglmer.nb <- glmer.nb(nT ~ scale(HullArea) + scale(maxCAPE) + scale(maxBS_deep) + scale(maxBS_shallow) + (1|Season), data = BigDays.sfdfT)
summary(modelglmer.nb) # no convergence if interaction term is included
summary(glm.nb(nT ~ scale(HullArea) + scale(maxCAPE) + scale(avgCIN) + scale(maxBS_deep) + scale(maxBS_shallow), data = BigDays.sfdfT))

modelFinal <- glm.nb(nT ~ HullArea + maxCAPE + maxBS_deep + maxBS_shallow, data = BigDays.sfdfT[BigDays.sfdfT$Mo %in% c(10, 11),])
summary(modelFinal)

modelFinalC <- glm.nb(GroupDayCas ~ totalPOP + maxCAPE + maxBS_deep + maxBS_shallow + Lat + Lon, data = BigDays.sfdfT[BigDays.sfdfT$Season,])
summary(modelFinalC)
hist(resid(modelFinalC))
range(exp(predict(modelFinalC)))
plot(log(BigDays.sfdfT$GroupDayCas), predict(modelFinalC))
cor(BigDays.sfdfT$GroupDayCas, exp(predict(modelFinalC)))
```

## Cross validation
```{r}
logCount <- numeric()
for(i in 1:nrow(BigDays.sfdfT)){
logCount[i] <- predict(glm.nb(nT ~ HullArea + maxCAPE + maxBS_deep + maxBS_shallow, data = BigDays.sfdfT[-i, ]), 
                       newdata = BigDays.sfdfT[i,])
}
cor(BigDays.sfdfT$nT, exp(logCount))
```

## Predictions
```{r}
predict(modelFinal, newdata = data.frame(HullArea = c(mean(BigDays.sfdfT$HullArea), mean(BigDays.sfdfT$HullArea)),
                                         maxCAPE = c(0, 5000),
                                         maxBS_deep = c(mean(BigDays.sfdfT$maxBS_deep), mean(BigDays.sfdfT$maxBS_deep)),
                                         maxBS_shallow = c(mean(BigDays.sfdfT$maxBS_shallow), mean(BigDays.sfdfT$maxBS_shallow))),
        type = "response")

1 - pnbinom(50, size = 1, mu = 18.725) # chance that the outbreak will have more than 50 tornadoes
1 - pnbinom(50, size = 1, mu = 21.55) 
```
      

Note the significance of the marginal effects depend on the scale but not the significance of the independent variables.

## Log-linear models

Protocol
(1) Use a log-linear regression model and a stepwise procedure `step()` with `direction = "both"`
(2) Remove variables with the wrong sign (indicative of collinearity)
(3) Successively remove additional variables with Pr(>|t|) > .01. If two variables are close in t-value pick the physical one over location
(4) Add month (`Mo`) as a random effects term (use `lmer`). Is there a seasonality?
(5) Can the model be improved with an interaction between CAPE and BS_deep?
(6) Fit a final model adjusting the response variable as appropriate

### Cluster size
```{r}
df <- BigDays.sfdfT %>%
  st_drop_geometry() %>%
  dplyr::select(nT, HullArea, maxCAPE, maxDEW, maxHLCY, minCIN, maxUSTM, maxVSTM, maxBS_deep, maxBS_shallow, totalPOP, Lon, Lat)

step(lm(log(GroupDayCas + 1) ~ ., data = df), direction = "both")

summary(lm(log(nT) ~  HullArea + maxCAPE + maxUSTM + maxVSTM + maxBS_deep + maxBS_shallow, data = BigDays.sfdfT))

ranef(lmer(log(nT) ~  HullArea + maxCAPE + maxUSTM + maxVSTM + maxBS_deep + maxBS_shallow + (1|Mo), data = BigDays.sfdfT))

modelglmer.nb <- glmer.nb(nT ~ scale(HullArea) + scale(maxCAPE) * scale(maxBS_deep) + scale(maxBS_shallow) + scale(maxVSTM)  + (1|Mo), data = BigDays.sfdfT)
summary(modelglmer.nb)
modelglm.nb <- glm.nb(nT ~ scale(HullArea) + scale(maxCAPE) * scale(maxBS_deep) + scale(maxBS_shallow) + scale(maxVSTM), data = BigDays.sfdfT)
summary(modelglm.nb) # Better model

modelglmer.nb <- glmer.nb(GroupDayCas ~ scale(totalPOP) + scale(maxCAPE) + scale(maxBS_deep) + scale(maxBS_shallow) + scale(Lon) + (1|Mo), data = BigDays.sfdfT)
summary(modelglmer.nb) # Better model
modelglm.nb <- glm.nb(GroupDayCas ~ scale(totalPOP) + scale(maxCAPE) + scale(maxBS_deep) + scale(maxBS_shallow) + scale(Lat) + scale(Lon), data = BigDays.sfdfT)
summary(modelglm.nb)

modelglmer.nb <- glmer.nb(GroupDayFat ~ scale(totalPOP) + scale(maxCAPE) + scale(maxBS_deep) + scale(maxBS_shallow) + scale(Lon) + (1|Mo), data = BigDays.sfdfT)
summary(modelglmer.nb) # model does not converge
modelglm.nb <- glm.nb(GroupDayFat ~ scale(totalPOP) + scale(maxCAPE) + scale(maxBS_deep) + scale(maxBS_shallow) + scale(Lat) + scale(Lon), data = BigDays.sfdfT)
summary(modelglm.nb)




hist(resid(modelglmer.nb))
range(predict(modelglmer.nb, type = "response"))
plot(log(BigDays.sfdfT$GroupDayCas + 1), predict(modelglmer.nb))
cor(log(BigDays.sfdfT$GroupDayCas + 1), predict(modelglmer.nb))

summary(lm(log(nT) ~  HullArea + maxCAPE * maxBS_deep + maxVSTM + maxUSTM + maxBS_shallow, data = BigDays.sfdfT))

modelFinal <- lm(log(nT) ~ HullArea + maxCAPE * maxBS_deep + maxBS_shallow + maxVSTM, data = BigDays.sfdfT)
hist(resid(modelFinal))
range(exp(predict(modelFinal)))
plot(log(BigDays.sfdfT$nT), predict(modelFinal))
cor(BigDays.sfdfT$nT, exp(predict(modelFinal)))

summary(lm(log(GroupDayCas + 1) ~  totalPOP + maxBS_deep + maxBS_shallow, data = BigDays.sfdfT))

modelFinalCas <- lm(log(GroupDayCas + 1) ~  totalPOP + maxBS_deep + maxBS_shallow, data = BigDays.sfdfT)
hist(resid(modelFinalCas))
range(exp(predict(modelFinalCas)))
plot(log(BigDays.sfdfT$GroupDayCas + 1), predict(modelFinalCas))
cor(BigDays.sfdfT$GroupDayCas + 1, exp(predict(modelFinal)))

modelFinal2 <- glm(I(nT - 10) ~  HullArea + maxBS_deep * maxCAPE + maxBS_shallow + maxVSTM, family = "poisson", data = BigDays.sfdfT)
range(predict(modelFinal2, type = "response") + 10)
plot(BigDays.sfdfT$nT, predict(modelFinal2, type = "response") + 10)
cor(BigDays.sfdfT$nT, predict(modelFinal2, type = "response") + 10)

library(MASS)
modelFinal3 <- glm.nb(nT ~  HullArea + maxBS_deep + maxCAPE + maxBS_shallow + maxVSTM, data = BigDays.sfdfT)
summary(modelFinal3)
range(predict(modelFinal3, type = "response"))
plot(BigDays.sfdfT$nT, predict(modelFinal3, type = "response"))
cor(BigDays.sfdfT$nT, predict(modelFinal3, type = "response"))

modelFinal4 <- glm.nb(nT ~  HullArea + maxBS_deep + maxCAPE + maxBS_shallow + maxVSTM, data = BigDays.sfdfT)
summary(modelFinal4)
range(predict(modelFinal4, type = "response"))
plot(BigDays.sfdfT$nT, predict(modelFinal4, type = "response"))
cor(BigDays.sfdfT$nT, predict(modelFinal4, type = "response"))

modelFinalCas2 <- glm.nb(GroupDayCas  ~  totalPOP + maxCAPE + maxBS_deep + maxBS_shallow + maxUSTM, data = BigDays.sfdfT)
summary(modelFinalCas2)
range(predict(modelFinalCas2, type = "response"))
plot(log(BigDays.sfdfT$GroupDayCas + 1), predict(modelFinalCas2))
cor(log(BigDays.sfdfT$GroupDayCas + 1), predict(modelFinalCas2))

modelFinalFat2 <- glm.nb(GroupDayFat  ~  totalPOP + maxCAPE * maxBS_deep + maxBS_shallow, data = BigDays.sfdfT)
summary(modelFinalFat2)
range(predict(modelFinalFat2, type = "response"))
plot(log(BigDays.sfdfT$GroupDayFat + 1), predict(modelFinalFat2))
cor(log(BigDays.sfdfT$GroupDayFat + 1), predict(modelFinalFat2))
```

### Cluster area

```{r}
df <- BigDays.sfdfT %>%
  st_drop_geometry() %>%
  select(HullArea, maxCAPE, maxDEW, maxHLCY, minCIN, maxUSTM, maxVSTM, maxBS_deep, maxBS_shallow, totalPOP, Lon, Lat)

step(lm(log(as.numeric(HullArea)) ~ ., data = df), direction = "both")

summary(lm(log(as.numeric(HullArea)) ~  totalPOP + maxUSTM + minCIN + maxVSTM + maxDEW  + Lon + maxCAPE + Lat + maxBS_shallow, data = BigDays.sfdfT))
summary(lm(log(as.numeric(HullArea)) ~  totalPOP + maxUSTM + minCIN + maxVSTM + maxDEW  + Lon + maxCAPE + maxBS_shallow, data = BigDays.sfdfT))

ranef(lmer(log(as.numeric(HullArea)) ~  totalPOP + maxUSTM + minCIN + maxVSTM + maxDEW  + Lon + maxCAPE + maxBS_shallow + (1|Mo), data = BigDays.sfdfT))

summary(lm(log(as.numeric(HullArea)) ~  totalPOP + maxUSTM + minCIN + maxVSTM + maxDEW  + Lon + maxCAPE * maxBS_shallow, data = BigDays.sfdfT))

modelFinal <- lm(log(HullArea) ~  totalPOP + maxUSTM + minCIN + maxVSTM + maxDEW  + Lon + maxCAPE + maxBS_shallow, data = BigDays.sfdfT)
hist(as.numeric(resid(modelFinal)))
cor(BigDays.sfdfT$HullArea, exp(predict(modelFinal)))
plot(BigDays.sfdfT$HullArea, exp(predict(modelFinal)))

#modelFinal2 <- glm(I(as.numeric(HullArea)/10^8) ~ scale(totalPOP) + 
#                     scale(maxUSTM) + scale(minCIN) + scale(maxVSTM) + scale(maxDEW)  + scale(Lon) + 
#                     scale(maxCAPE) + scale(maxBS_shallow), family = "Gamma", data = BigDays.sfdfT)

```

### Cluster rate

```{r}
df <- BigDays.sfdfT %>%
  st_drop_geometry() %>%
  select(TorPerHour, maxCAPE, maxDEW, maxHLCY, minCIN, maxUSTM, maxVSTM, maxBS_deep, maxBS_shallow, totalPOP, Lon, Lat)

step(lm(log(TorPerHour) ~ ., data = df), direction = "both")

summary(lm(log(TorPerHour) ~  Lat + maxDEW + maxCAPE + totalPOP + maxBS_shallow + minCIN + maxVSTM + maxUSTM + maxHLCY, data = BigDays.sfdfT))
summary(lm(log(TorPerHour) ~  Lat + maxDEW + maxCAPE + totalPOP + maxBS_shallow + minCIN + maxVSTM + maxUSTM, data = BigDays.sfdfT))
summary(lm(log(TorPerHour) ~  Lat + maxDEW + maxCAPE + totalPOP + maxBS_shallow + minCIN + maxVSTM, data = BigDays.sfdfT))
summary(lm(log(TorPerHour) ~  Lat + maxDEW + maxCAPE + totalPOP + maxBS_shallow + minCIN, data = BigDays.sfdfT))
summary(lm(log(TorPerHour) ~  Lat + maxDEW + maxCAPE + totalPOP + maxBS_shallow, data = BigDays.sfdfT))
summary(lm(log(TorPerHour) ~  Lat + maxDEW + maxCAPE + totalPOP, data = BigDays.sfdfT))
```

## Cluster density

```{r}
df <- BigDays.sfdfT %>%
  st_drop_geometry() %>%
  select(TorPerKm, maxCAPE, maxDEW, maxHLCY, minCIN, maxUSTM, maxVSTM, maxBS_deep, maxBS_shallow, totalPOP, Lon, Lat)

step(lm(log(TorPerKm) ~ ., data = df), direction = "both")

summary(lm(log(TorPerKm) ~  maxUSTM + maxDEW + totalPOP + minCIN + Lon + maxVSTM + Lat, data = BigDays.sfdfT))
summary(lm(log(TorPerKm) ~  maxUSTM + maxDEW + totalPOP + minCIN + Lon + maxVSTM, data = BigDays.sfdfT))

summary(lm(log(TorPerHour) ~  Lat + maxDEW + maxCAPE + totalPOP + maxBS_shallow + minCIN + maxVSTM + maxUSTM, data = BigDays.sfdfT))
summary(lm(log(TorPerHour) ~  Lat + maxDEW + maxCAPE + totalPOP + maxBS_shallow + minCIN + maxVSTM, data = BigDays.sfdfT))
summary(lm(log(TorPerHour) ~  Lat + maxDEW + maxCAPE + totalPOP + maxBS_shallow + minCIN, data = BigDays.sfdfT))
summary(lm(log(TorPerHour) ~  Lat + maxDEW + maxCAPE + totalPOP + maxBS_shallow, data = BigDays.sfdfT))
summary(lm(log(TorPerHour) ~  Lat + maxDEW + maxCAPE + totalPOP, data = BigDays.sfdfT))
```

## CAPE-Shear

```{r}
df <- BigDays.sfdfT %>% 
# filter(Mo %in% c(9, 10, 11)) %>%
  st_drop_geometry() %>%
  select(Y = maxCAPE, X = maxBS_deep, Z = nT)
cor(df$Y, df$X)

theta = seq(1, 180, by = 1)
r = NULL ; pval = NULL
for (k in theta){
  C1 = cos(k * pi/180)
  C2 = sin(k * pi/180)
  CapeShear = C1 * scale(df$X) + C2 * scale(df$Y)
  ctest = cor.test(CapeShear, df$Z)
  r = c(r, as.numeric(ctest$estimate))
  pval = c(pval, as.numeric(ctest$p.value))
}
range(r)

plot.df <- data.frame(theta, C1 = cos(theta * pi/180), C2 = sin(theta * pi/180), r)
ggplot(plot.df, aes(x = C1, y = C2, color = r)) +
  geom_line() +
  coord_polar()
  

signif = .01
plot(-10, -10, xlim=c(-.75, 1.05), ylim=c(-.75, 1.05), axes=FALSE, xlab='', ylab='', main='')

i = seq(0, 360, .5)
Outl = cbind(.75 * cos(i * pi/180), .75 *sin(i * pi/180))
Innl = cbind(.25 * cos(i * pi/180), .25 * sin(i * pi/180))

polygon(Outl[, 1], Outl[, 2], border=colors()[229], col='white', lwd=2)
polygon(Innl[, 1], Innl[, 2], border=colors()[229], col=NULL, lwd=2)

Line.xcord = c(-.75, .75, NA, 0, 0, NA, -cos(pi/4), cos(pi/4), NA, -cos(pi/4), cos(pi/4))
Line.ycord = c(0, 0, NA, -.75, .75, NA, sin(pi/4), -sin(pi/4), NA, -sin(pi/4), sin(pi/4))
lines(Line.xcord, Line.ycord, col=colors()[229], lwd=1)

text(par('usr')[2] - 0.29, 0.0, srt=0, adj = 0, labels = 'Shear', xpd = TRUE, cex=1.3) 
text(par('usr')[2] - 0.6, 0.81, srt=0, adj = 0, labels = '', xpd = TRUE, cex=1.3)
text(par('usr')[2] - 1.52, 1.17, srt=0, adj = 0, labels = 'CAPE', xpd = TRUE, cex=1.3)
text(par('usr')[2] - 0.6, -0.81, srt=0, adj = 0, labels = '', xpd = TRUE, cex=1.3)
text(0,0.3, '0.25', cex=1.4, col=colors()[229])
text(0,0.8, '0.75', cex=1.4, col=colors()[229])

dg = theta
polygon(r * cos(dg * pi/180), r * sin(dg * pi/180), border="#ff9900", lwd=7, col=NULL)
r2 = c(r[which.max(pval):length(pval)], r[1:(which.max(pval) - 1)])
pval2 = c(pval[which.max(pval):length(pval)], pval[1:(which.max(pval) - 1)])
dg2 = c(dg[which.max(pval):length(pval)], dg[1:(which.max(pval) - 1)])
lines(r2[pval2 <= signif] * cos(dg2[pval2 <= signif] * pi/180),
      r2[pval2 <= signif] * sin(dg2[pval2 <= signif] * pi/180), col="#cc3300", lwd=7) 
```

